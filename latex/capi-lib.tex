\documentclass[landscape,twocolumn,10pt,a4paper]{article}
\usepackage{graphicx} 
\usepackage{subfiles} 
\usepackage{titlesec}
\usepackage{minted}

\usepackage{geometry}
\geometry{%
  top=1.5cm, 
  bottom=1.5cm, 
  inner=1.5cm, 
  outer=1.5cm, 
  heightrounded, 
  bindingoffset=0.5cm % Espaço adicional para a encadernação, se necessário
}

\setlength{\columnseprule}{0.4pt}
\setminted{
    breaklines=true,      % Quebra de linha automática
    breakanywhere=true,
    breaksymbolleft={},   % Sem símbolo de quebra de linha
    breakindent=0pt,      % Sem indentação nas linhas quebradas
    breaksymbolsepleft=0pt, % Sem separação para o símbolo de quebra
}


\title{Capi-Library
}
\author{Bruno Rezendo, Dener Ribeiro, Samuel Raimundo}
% \date{May 2024}

\begin{document}

\maketitle

\tableofcontents\section{D&C}
\subsection{binarySearch}
\begin{minted}{cpp}

// binarySearchFirstTrue: Encontra o primeiro valor verdadeiro de p no intervalo [l, r].
// binarySearchLastFalse: Encontra o último valor falso de p no intervalo [l, r].
// binarySearchContinuous: Busca binária para valores contínuos para encontrar o limite onde p se torna verdadeiro.
// Complexidade: O(log(r - l))

bool p(int x) {
    return x >= 4;
}

int binarySearchFirstTrue(int l, int r) {
    while(l<r) {
        int m = l + (r-l)/2;

        p(m) ? r = m : l = m+1;
    }
    return p(l) ? l : -1;
}

int binarySearchLastFalse(int l, int r) {
    while(l<r) {
        int m = l + (r-l+1)/2;
        p(m) ? r = m-1 : l = m;
    }
    return p(l) ? -1 : l;
}

double binarySearchContinuous(double l, double r) {
    for(int i=0;i<100;i++) {
        double m = l + (r-l)/2;
        p(m) ? r = m : l = m;
    }
    return l; 
}


\end{minted}

\subsection{ternarySearch}
\begin{minted}{cpp}

// ternarySearchGetMin: Realiza uma busca ternária no intervalo [l, r] para encontrar o mínimo valor da função fMin
// ternarySearchGetMax: Realiza uma busca ternária no intervalo [l, r] para encontrar o máximo valor da função fMax
// Complexidade: O(log(n))

double fMin(double x){
    return abs(500.0-x);
}

double ternarySearchGetMin(double l, double r) {
    // double eps = 1e-9;              //set the error limit here
    // while (r - l > eps) {
    for (int i = 0; i < 100; ++i) {
        double delta = (r - l) / 3;
        double m1 = l + delta;
        double m2 = r - delta;
        (fMin(m1) > fMin(m2)) ? l = m1 : r = m2;
    }
    return l;
}

double fMax(double x){
    return 1000.0 - abs(500.0-x);
}

double ternarySearchGetMax(double l, double r) {
    // double eps = 1e-9;              //set the error limit here
    // while (r - l > eps) {
    for (int i = 0; i < 100; ++i) {
        double delta = (r - l) / 3;
        double m1 = l + delta;
        double m2 = r - delta;
        (fMax(m1) > fMax(m2)) ? r = m2 : l = m1;
    }
    return l;
}

\end{minted}

\section{DP}
\subsection{01Knapsack}
\begin{minted}{cpp}

// 0-1 Knapsack - Problema da Mochila
// A resposta é obtida chamando dp(0, S), onde S é o tamanho máximo da mochila
// Complexidade: O(nS)

int N, V[MAX_N], W[MAX_N], memo[MAX_N][MAX_W];

int dp(int id, int remW) {
  if ((id == N) || (remW == 0)) return 0;
  int &ans = memo[id][remW];
  if (ans != -1) return ans;
  if (W[id] > remW) return ans = dp(id+1, remW);
  return ans = max(dp(id+1, remW), V[id]+dp(id+1, remW-W[id]));
}

\end{minted}

\subsection{DC_DP}
\begin{minted}{cpp}

// Divide and Conquer DP
// recorrencia: dp(i,j) = min{0<=k<=j} dp(i-1,k-1) + C(k,j);
// precisa que opt seja monotono 
// no geral isso acontece quando 
// C(a, c) + C(b, d) <=  C(a, d) + C(b, c)
// para a <= b <= c <= d

vector<vector<ll>> dp;

int query(int i,int j){}

void dc_dp(int l,int r, int optl,int optr,int k){
    if(l>r) return;
    int mid = (l+r)/2, pos = -1;;
    ll best = INT_MAX;
    for(int j=optl;j<=min(mid,optr);j++){
        ll curCost = dp[k-1][j-1]+query(j,mid);
        if(curCost<best){
            best = curCost;
            pos = j;
        }
    }
    dp[k][mid] = best;
    dc_dp(l,mid-1,optl,pos,k);
    dc_dp(mid+1,r,pos,optr,k);
}

int solve(int n,int k){
    dp.resize(2,vector<ll>(n+1,INF));
    dp[0][0] = 0;
    for(int i=1;i<=k;i++){
        dc_dp(1,n,1,n,i);
    }
    return (dp[k][n]);
}

\end{minted}

\subsection{LIS}
\begin{minted}{cpp}

// Longest Increasing Subsequence
// O(n log n)

int A[MAX_N];

void print_LIS(int i) {
    if (p[i] == -1) { printf("%d", A[i]); return; }
    print_LIS(p[i]);
    cout << A[i] << endl;
}

int lis(int n) {
    int k = 0, lis_end = 0;
    vi L(n, 0), L_id(n, 0);
    p.assign(n, -1);
    for (int i = 0; i < n; ++i) {
        int pos = lower_bound(L.begin(), L.begin()+k, A[i]) - L.begin();
        L[pos] = A[i];
        L_id[pos] = i;
        p[i] = pos ? L_id[pos-1] : -1;
        if (pos == k) {
            k = pos+1;
            lis_end = i;
        }
    }

    print_LIS(lis_end);

    return k; // length of LIS
}

\end{minted}

\subsection{Max1DRangeSum}
\begin{minted}{cpp}

// Max 1D Range Sum
// O(n)

int max1DRangeSum(vector<int> A, int n) {
  int sum = 0, ans = 0;
  for (int i = 0; i < n; ++i) {
    sum += A[i];
    ans = max(ans, sum);
    if (sum < 0) sum = 0;
  }
  return ans;
}

\end{minted}

\subsection{Max2DRangeSum}
\begin{minted}{cpp}

// Max 2D Range Sum
// Find a sub-matrix of A with the maximum sum
// O(n^3)

#define MAX_n 110
int A[MAX_n][MAX_n];

int max2DRangeSum(int n) {
  for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j) {
      if (j > 0) A[i][j] += A[i][j-1];
    }
  int maxSubRect = INT_MIN; // lowest possible val
  for (int l = 0; l < n; ++l)
    for (int r = l; r < n; ++r) {
      int subRect = 0;
      for (int row = 0; row < n; ++row) {
        if (l > 0) subRect += A[row][r] - A[row][l-1];
        else       subRect += A[row][r];
        if (subRect < 0) subRect = 0;
        maxSubRect = max(maxSubRect, subRect);
      }
    }
  return maxSubRect;
}


\end{minted}

\subsection{TSP}
\begin{minted}{cpp}

// Traveling-Salesman-Problem
// A resposta é encontrada ao chamar: 
// dp(0, (1<<(n-1))-1)
// Complexidade: O(2^(n-1) * n^2)
// Permite resolução até n = [18..19].

#define LSOne(S) ((S) & -(S))

const int MAX_n = 11;

int dist[MAX_n][MAX_n], memo[MAX_n][1<<(MAX_n-1)];

int dp(int u, int mask) {
  if (mask == 0) return dist[u][0];
  int &ans = memo[u][mask];
  if (ans != -1) return ans;
  ans = INT_MAX;
  int m = mask;
  while (m) {
    int lso = LSOne(m);
    int v = __builtin_ctz(lso)+1;
    ans = min(ans, dist[u][v] + dp(v, mask^lso));
    m -= lso;
  }
  return ans;
}

\end{minted}

\subsection{editDistance}
\begin{minted}{cpp}

// Distancia de edição 
// retorna a menor quantidade de edição entre inserir,
// remover e editar, para transformar s1 em s2

int editDist(string s1, string s2){
    int m = s1.size();
    int n = s2.size();
    int prev; 
    vector<int> curr(n + 1, 0); 
    for (int j = 0; j <= n; j++) curr[j] = j;
  
    for (int i = 1; i <= m; i++){
        prev = curr[0]; 
        curr[0] = i;
        for (int j = 1; j <= n; j++){
            int temp = curr[j];
            if (s1[i - 1] == s2[j - 1]) curr[j] = prev;
            else curr[j] = 1 + min({curr[j - 1], prev, curr[j]});
            prev = temp;
        }
    }
    return curr[n];
}

\end{minted}

\section{Estruturas}
\subsection{fenwickTree}
\begin{minted}{cpp}

// Fenwick Tree (BIT)
// 1-indexado
// Se criar a partir de um array, arr[0] deve ser = 0
// Complexidade: O(NlogN)

#define LSOne(S) ((S) & -(S))

typedef long long ll;
typedef vector<ll> vll;
typedef vector<int> vi;

// Point update, range query
class FenwickTree {
private:
  vll ft;
public:
  FenwickTree(int m) { ft.assign(m+1, 0); }

  void build(const vll &f) {
    int m = (int)f.size()-1;
    ft.assign(m+1, 0);
    for (int i = 1; i <= m; ++i) {
      ft[i] += f[i];
      if (i+LSOne(i) <= m)
        ft[i+LSOne(i)] += ft[i];
    }
  }

  FenwickTree(const vll &f) { build(f); }

  FenwickTree(int m, const vi &s) {
    vll f(m+1, 0);
    for (int i = 0; i < (int)s.size(); ++i)
      ++f[s[i]];
    build(f);
  }

  ll rsq(int j) {
    ll sum = 0;
    for (; j; j -= LSOne(j))
      sum += ft[j];
    return sum;
  }

  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); }

  // updates value of the i-th element by v (v can be +ve/inc or -ve/dec)
  void update(int i, ll v) {
    for (; i < (int)ft.size(); i += LSOne(i))
      ft[i] += v;
  }

  // find the smallest index i so that
  // the sum in the range [1..i] >= k.
  int select(ll k) { // O(log m)
    int p = 1;
    while (p*2 < (int)ft.size()) p *= 2;
    int i = 0;
    while (p) {
      if (k > ft[i+p]) {
        k -= ft[i+p];
        i += p;
      }
      p /= 2;
    }
    return i+1;
  }
};

// Range update, point query
class RUPQ {
private:
  FenwickTree ft;
public:
  RUPQ(int m) : ft(FenwickTree(m)) {}
  void range_update(int ui, int uj, ll v) {
    ft.update(ui, v);
    ft.update(uj+1, -v);
  }
  ll point_query(int i) { return ft.rsq(i); }
};

// Range update, range query
class RURQ  {
private:
  RUPQ rupq;
  FenwickTree purq;
public:
  RURQ(int m) : rupq(RUPQ(m)), purq(FenwickTree(m)) {}
  void range_update(int ui, int uj, ll v) {
    rupq.range_update(ui, uj, v);
    purq.update(ui, v*(ui-1));
    purq.update(uj+1, -v*uj);
  }
  ll rsq(int j) {
    return rupq.point_query(j)*j -
           purq.rsq(j);
  }
  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); }
};


\end{minted}

\subsection{segmentTree}
\begin{minted}{cpp}

// Segment Tree
// 0-indexado
// Complexidade: O(NlogN)

typedef vector<int> vi;

class SegmentTree {
private:
  int n;
  vi A, st, lazy;

  int l(int p) { return  p<<1; }
  int r(int p) { return (p<<1)+1; }

  int conquer(int a, int b) {
    if (a == -1) return b;
    if (b == -1) return a;
    return min(a, b);
  }

  void build(int p, int L, int R) {
    if (L == R)
      st[p] = A[L];
    else {
      int m = (L+R)/2;
      build(l(p), L  , m);
      build(r(p), m+1, R);
      st[p] = conquer(st[l(p)], st[r(p)]);
    }
  }

  void propagate(int p, int L, int R) {
    if (lazy[p] != -1) {
      st[p] = lazy[p];
      if (L != R)
        lazy[l(p)] = lazy[r(p)] = lazy[p];
      else
        A[L] = lazy[p];
      lazy[p] = -1;
    }
  }

  int RMQ(int p, int L, int R, int i, int j) {
    propagate(p, L, R);
    if (i > j) return -1;
    if ((L >= i) && (R <= j)) return st[p];
    int m = (L+R)/2;
    return conquer(RMQ(l(p), L  , m, i          , min(m, j)),
                   RMQ(r(p), m+1, R, max(i, m+1), j        ));
  }

  void update(int p, int L, int R, int i, int j, int val) { // O(log n)
    propagate(p, L, R);
    if (i > j) return;
    if ((L >= i) && (R <= j)) {
      lazy[p] = val;
      propagate(p, L, R);
    }
    else {
      int m = (L+R)/2;
      update(l(p), L  , m, i          , min(m, j), val);
      update(r(p), m+1, R, max(i, m+1), j        , val);
      int lsubtree = (lazy[l(p)] != -1) ? lazy[l(p)] : st[l(p)];
      int rsubtree = (lazy[r(p)] != -1) ? lazy[r(p)] : st[r(p)];
      st[p] = conquer(lsubtree, rsubtree);
    }
  }

public:
  SegmentTree(int sz) : n(sz), A(n), st(4*n), lazy(4*n, -1) {}

  SegmentTree(const vi &initialA) : SegmentTree((int)initialA.size()) {
    A = initialA;
    build(1, 0, n-1);
  }

  void update(int i, int j, int val) { update(1, 0, n-1, i, j, val); }

  int RMQ(int i, int j) { return RMQ(1, 0, n-1, i, j); }
};



\end{minted}

\subsection{unionFind}
\begin{minted}{cpp}

// Union-Find Disjoint Sets
// 0-indexado
// Complexidade: O(N)
// findSet: O(1) amortizado
// isSameSet: O(1) amortizado
// unionSet: O(1) amortizado
// numDisjointSets: O(1)
// sizeOfSet: O(1) amortizado

#include <bits/stdc++.h>
using namespace std;

typedef vector<int> vi;

class UnionFind {
private:
  vi p, rank, setSize;
  int numSets;
public:
  UnionFind(int N) {
    p.assign(N, 0); for (int i = 0; i < N; ++i) p[i] = i;
    rank.assign(N, 0);                           // optional speedup
    setSize.assign(N, 1);                        // optional feature
    numSets = N;                                 // optional feature
  }

  int findSet(int i) { return (p[i] == i) ? i : (p[i] = findSet(p[i])); }
  bool isSameSet(int i, int j) { return findSet(i) == findSet(j); }

  int numDisjointSets() { return numSets; }      // optional
  int sizeOfSet(int i) { return setSize[findSet(i)]; } // optional

  void unionSet(int i, int j) {
    if (isSameSet(i, j)) return;
    int x = findSet(i), y = findSet(j);
    if (rank[x] > rank[y]) swap(x, y);
    p[x] = y;
    if (rank[x] == rank[y]) ++rank[y];
    setSize[y] += setSize[x];
    --numSets;
  }
};


\end{minted}

\subsection{waveletTree}
\begin{minted}{cpp}

// Wavelet Tree
// waveletTree: construtor
// exemplo: waveletTree wt(v.begin(), v.end(), menorValorDoIntervalo, maiorValorDoIntervalo)
// count: Conta os elementos no intervalo [l, r] que são iguais a k. O intervalo é 1-indexado.
// kth: Encontra o k-ésimo menor elemento no intervalo [l, r]. O intervalo é 1-indexado.
// lte: Conta os elementos no intervalo [l, r] que são menores ou iguais a k. O intervalo é 1-indexado.
// swap: Troca o elemento com índice i com o elemento com índice i+1. O índice é 1-indexado.
// Complexidade das operações: O(log n)

struct waveletTree {
    int lo, hi;
    waveletTree *l, *r;
    vector<int> b;

    waveletTree(vector<int>::iterator from, vector<int>::iterator to, int x, int y) {
        lo = x, hi = y;

        if(from == to or hi == lo) return;

        b.reserve(to - from + 1);
        b.push_back(0);

        int mid = (lo+hi)/2;
        auto f = [mid](int x){
			return x <= mid;
		};

        for(auto it = from; it != to; it++)
			b.push_back(b.back() + f(*it));

        auto pivot = stable_partition(from, to, f);
		l = new waveletTree(from, pivot, lo, mid);
		r = new waveletTree(pivot, to, mid+1, hi);
    }

	int count(int l, int r, int k) {
		if(l > r or k < lo or k > hi) return 0;
		if(lo == hi) return r - l + 1;
		int lb = b[l-1], rb = b[r], mid = (lo+hi)/2;
		if(k <= mid) return this->l->count(lb+1, rb, k);
		return this->r->count(l-lb, r-rb, k);
	}

	int kth(int l, int r, int k){
		if(l > r) return 0;
		if(lo == hi) return lo;
		int lb = b[l-1];
		int rb = b[r];
		int inLeft = rb - lb;
		if(k <= inLeft) return this->l->kth(lb+1, rb , k);
		return this->r->kth(l-lb, r-rb, k-inLeft);
	}

	int lte(int l, int r, int k) {
		if(l > r or k < lo) return 0;
		if(hi <= k) return r - l + 1;
		int lb = b[l-1], rb = b[r];
		return this->l->lte(lb+1, rb, k) + this->r->lte(l-lb, r-rb, k);
	}

    void swap(int i) {
        if (lo == hi or i >= b.size() or i <= 0) return;
        bool iLeft = b[i] > b[i-1];
        bool i1Left = b[i+1] > b[i];
        if (iLeft && i1Left) this->l->swap(b[i]);
        if (!iLeft && !i1Left) this->r->swap(i-b[i]);
        if (iLeft && !i1Left) b[i]--;
        if (!iLeft && i1Left) b[i]++;
    }
};

\end{minted}

\section{Grafos}
\subsection{2sat}
\begin{minted}{cpp}

// Algoritmo 2-SAT usando Kosaraju
// init: Inicializa as estruturas de dados
// addDisjunction: Adiciona uma disjunção - na e nb significam se a e b devem ser negados
// solve2Sat: Resolve o problema 2-SAT e retorna verdadeiro se houver uma solução
// res[i]: Valor que a i-ésima variável deve assumir para a resposta ser válida
// Complexidade das operações: O(V + E)
/*
    init(2*n)
    f(i,0,m) addDisjunction(a, c1 == '-', b, c2 == '-')
    if (solve2Sat(n))
        for (i,0,n) cout << res[i];
*/
const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> reverseGraph(MAXN);
vector<int> visited(MAXN);
vector<int> exitOrder;
vector<int> componentOfV(MAXN);
vector<bool> res(MAXN);
vector<vector<int>> components;

void init(int numV) {
    exitOrder.clear();
    components.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        reverseGraph[i].clear();
        visited[i] = 0;
    }
}

void dfs(int v) {
    visited[v] = 1;

    for (int u : graph[v]) if (visited[u] == 0) dfs(u);

    exitOrder.push_back(v);
}

void dfs2(int v, int c) {
    visited[v] = 2;
    componentOfV[v] = c;
    components.back().push_back(v);

    for (int u : reverseGraph[v]) if (visited[u] == 1) dfs2(u, c);
}

void addDisjunction(int a, bool na, int b, bool nb) {
    a = 2*a ^ na;
    b = 2*b ^ nb;
    int negA = a ^ 1;
    int negB = b ^ 1;

    graph[negA].push_back(b);
    graph[negB].push_back(a);
    reverseGraph[b].push_back(negA);
    reverseGraph[a].push_back(negB);
}

bool solve2Sat(int n) {
    for (int i = 0; i < 2*n; i++) if(visited[i] == 0) dfs(i);

    int componentId = 0;
    for (int i = exitOrder.size()-1; i >= 0; i--) if(visited[exitOrder[i]] == 1) {
        components.push_back(vector<int>());
        dfs2(exitOrder[i], componentId++);
    }

    for (int i = 0; i < n; i++) {
        if (componentOfV[2*i] == componentOfV[2*i+1]) return false;

        res[i] = (componentOfV[2*i] > componentOfV[2*i+1]);
    }
    return true;
}


\end{minted}

\subsection{articulationPoints}
\begin{minted}{cpp}

// Algoritmo para encontrar pontos de articulação em um grafo
// articulationPoints: vetor com os índices dos articulation points
// Complexidade das operações: O(V + E)
/*
    init(n);
    f(i,0,m) {
        graph[a].push_back(b);
        graph[b].push_back(a);
    }
    f(i,0,n) if(!visited[i]) dfs(i,i);
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<bool> visited(MAXN);
vector<int> articulationPoints;
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
int entryTime;

void init(int numV) {
    entryTime = 0;
    articulationPoints.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        visited[i] = false;
    }
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;

    bool isArticulationPoint = false;
    int numChildren = 0;

    for (int u : graph[v]) {
        if (!visited[u]) {
            numChildren++;
            
            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);

            if (lowlink[u] >= tin[v]) isArticulationPoint = true;
        } else {
            if (u == parent) continue;

            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }

    if (v == parent && numChildren >= 2) articulationPoints.push_back(v);
    if (v != parent && isArticulationPoint) articulationPoints.push_back(v);
}


\end{minted}

\subsection{biconnectedComponents}
\begin{minted}{cpp}

// Componentes Biconexas = Componentes Conectadas por 2-Vértices
// findBiconnectedComponents: Encontra todos os componentes biconexos no grafo
// bcc: vetor de componentes biconexas
// bcc[i]: vetor de arestas que representam o i-ésimo bcc
// Complexidade das operações: O(V + E)
/*
    init(n, m);
    f(i,0,m) {
        graph[a].push_back(b);
        graph[b].push_back(a);
        edgeIds[a].push_back(i);
        edgeIds[b].push_back(i);
        edges[i] = {a, b};
    }
    findBiconnectedComponents(n);
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> edgeIds(MAXN);
vector<pair<int,int>> edges(MAXN);
vector<bool> visited(MAXN);
vector<bool> edgeVisited(MAXN);
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
vector<int> isArticulationPoint(MAXN);
stack<int> edgesStack;
vector<vector<pair<int,int>>> bcc;
int entryTime;

void init(int numV, int numE) {
    entryTime = 0;
    bcc.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        edgeIds[i].clear();
        visited[i] = false;
        isArticulationPoint[i] = false;
    }
    for (int i = 0; i < 2*numE; i++) {
        edgeVisited[i] = false;
    }
}

void newBiconnectedComponent (int edgeId) {
    if(edgesStack.empty()) return;
    
    vector<pair<int,int>> newComponent;
    int currId;
    do {
        currId = edgesStack.top();
        newComponent.push_back(edges[currId]);
        edgesStack.pop();
        if(edgesStack.empty()) break;
    } while(currId != edgeId);
    bcc.push_back(newComponent);
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;

    int numChildren = 0;
    for (int i = 0; i < graph[v].size(); i++) {
        int u = graph[v][i];
        int edgeId = edgeIds[v][i];

        if (edgeVisited[edgeId]) continue;
        edgeVisited[edgeId] = true;
        edgesStack.push(edgeId);

        if (!visited[u]) {
            numChildren++;

            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);

            bool foundNewComponent = false;
            if (v == parent && numChildren >= 2) foundNewComponent = true;
            if (v != parent && lowlink[u] >= tin[v]) foundNewComponent = true;

            if (foundNewComponent) {
                isArticulationPoint[v] = true;
                newBiconnectedComponent(edgeId);
            }
        } else {
            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }
}

void findBiconnectedComponents(int n) {
    for (int i = 0; i < n; i++) {
        if(!visited[i]) {
            dfs(i,i);
            newBiconnectedComponent(-1);
        }
    }
}


\end{minted}

\subsection{blockCutTree}
\begin{minted}{cpp}

// Block Cut Tree - Árvore dos pontos de articulação
// findBiconnectedComponents: Encontra todos os componentes biconexos no grafo
// generateBlockCutTree: Gera a block-cut tree usando os componentes biconexos
// bcc: vetor de componentes biconexas
// bcc[i]: vetor de arestas que representam o i-ésimo bcc
// blockCutTree: Vetor de adjacências da block-cut tree
// blockCutTree[i]: Lista de vértices adjacentes ao vértice i na block-cut tree
// blockCutTree[i][j]: J-ésimo vértice adjacente ao vértice i na block-cut tree
// componentId: Número de vértices na block-cut tree
// Complexidade das operações: O(V + E)
/*
    init(n, m);
    f(i,0,m) {
        graph[a].push_back(b);
        graph[b].push_back(a);
        edgeIds[a].push_back(i);
        edgeIds[b].push_back(i);
        edges[i] = {a, b};
    }
    findBiconnectedComponents(n);
    generateBlockCutTree(n);
    for (int i = 0; i < componentId; i++) {
        for (int j = 0; j < blockCutTree[i].size(); j++) {
            cout << "(" << i+1 << ", " << blockCutTree[i][j]+1 << ") ";
        }
    }
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> blockCutTree(MAXN);
vector<vector<int>> edgeIds(MAXN);
vector<pair<int,int>> edges(MAXN);
vector<bool> visited(MAXN);
vector<bool> compVisited(MAXN);
vector<bool> edgeVisited(MAXN);
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
vector<int> isArticulationPoint(MAXN);
stack<int> edgesStack;
vector<int> componentOfEdge(MAXN);
int componentId;
vector<vector<pair<int,int>>> bcc;
int entryTime;

void init(int numV, int numE) {
    entryTime = 0;
    componentId = 0;
    bcc.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        blockCutTree[i].clear();
        edgeIds[i].clear();
        visited[i] = false;
        isArticulationPoint[i] = false;
    }
    for (int i = 0; i < 2*numE; i++) {
        edgeVisited[i] = false;
    }
}

void newBiconnectedComponent (int edgeId) {
    if(edgesStack.empty()) return;
    
    vector<pair<int,int>> newComponent;
    int currId;
    do {
        currId = edgesStack.top();
        newComponent.push_back(edges[currId]);
        componentOfEdge[currId] = componentId;
        edgesStack.pop();
        if(edgesStack.empty()) break;
    } while(currId != edgeId);
    bcc.push_back(newComponent);
    componentId++;
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;

    int numChildren = 0;
    for (int i = 0; i < graph[v].size(); i++) {
        int u = graph[v][i];
        int edgeId = edgeIds[v][i];

        if (edgeVisited[edgeId]) continue;
        edgeVisited[edgeId] = true;
        edgesStack.push(edgeId);

        if (!visited[u]) {
            numChildren++;

            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);

            bool foundNewComponent = false;
            if (v == parent && numChildren >= 2) foundNewComponent = true;
            if (v != parent && lowlink[u] >= tin[v]) foundNewComponent = true;

            if (foundNewComponent) {
                isArticulationPoint[v] = true;
                newBiconnectedComponent(edgeId);
            }
        } else {
            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }
}

void findBiconnectedComponents(int n) {
    for (int i = 0; i < n; i++) {
        if(!visited[i]) {
            dfs(i,i);
            newBiconnectedComponent(-1);
        }
    }
}

void generateBlockCutTree(int n) {
    for (int i = 0; i < n; i++) {
        if (!isArticulationPoint[i]) continue;
        for (int edgeId : edgeIds[i]) {
            int comp = componentOfEdge[edgeId];
            if (!compVisited[comp]) {
                compVisited[comp] = true;
                blockCutTree[componentId].push_back(comp);
                blockCutTree[comp].push_back(componentId);
            }
        }
        for (int edgeId : edgeIds[i]) {
            int comp = componentOfEdge[edgeId];
            compVisited[comp] = false;
        }
        componentId++;
    }
}


\end{minted}

\subsection{bridgeTreeEbcc}
\begin{minted}{cpp}

// Bridge Tree / Edge-Biconnected Components
// NÃO FUNCIONA COM ARESTAS MÚLTIPLAS
// Encontra os EBCC de um grafo não direcionado
// ebcc: vetor de EBCCs
// Complexidade: O(V + E)
/*
    init(n);
    f(i,0,m){
        graph[a].push_back(b);
        graph[b].push_back(a);
    }
    f(i,0,n) if(!visited[i]) dfs(i,i);
*/
#include "bits/stdc++.h"

#define ll long long

using namespace std;

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<bool> visited(MAXN);
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
stack<int> vertices;
vector<vector<int>> ebcc;
int entryTime;

void init(int numV) {
    entryTime = 0;
    ebcc.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        visited[i] = false;
    }
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;
    vertices.push(v); 

    for (int u : graph[v]) {
        if (!visited[u]) {
            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);
        } else {
            if (u == parent) continue;

            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }

    if (lowlink[v] == tin[v]) {
        vector<int> newComponent;
        do {
            newComponent.push_back(vertices.top());
            vertices.pop();
        } while (newComponent.back() != v);

        ebcc.push_back(newComponent);
    }
}


\end{minted}

\subsection{bridgeTreeEbccMultipleEdges}
\begin{minted}{cpp}

// Bridge Tree / Edge-Biconnected Components
// Versão que lida com arestas múltiplas
// Encontra os EBCC de um grafo não direcionado
// ebcc: vetor de EBCCs
// Complexidade: O(V + E)
/*
    init(n, m);
    f(i,0,m) {
        graph[a].push_back(b);
        graph[b].push_back(a);
        edgeIds[a].push_back(i);
        edgeIds[b].push_back(i);
    }
    f(i,0,n) if(!visited[i]) dfs(i,i);
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> edgeIds(MAXN);
vector<bool> visited(MAXN);
vector<bool> edgeVisited(MAXN);
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
stack<int> vertices;
vector<vector<int>> ebcc;
int entryTime;

void init(int numV, int numE) {
    entryTime = 0;
    ebcc.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        edgeIds[i].clear();
        visited[i] = false;
    }
    for (int i = 0; i < 2*numE; i++) {
        edgeVisited[i] = false;
    }
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;
    vertices.push(v); 

    for (int i = 0; i < graph[v].size(); i++) {
        int u = graph[v][i];
        int edgeId = edgeIds[v][i];

        if (edgeVisited[edgeId]) continue;
        edgeVisited[edgeId] = true;

        if (!visited[u]) {
            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);
        } else {
            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }

    if (lowlink[v] == tin[v]) {
        vector<int> newComponent;
        do {
            newComponent.push_back(vertices.top());
            vertices.pop();
        } while (newComponent.back() != v);

        ebcc.push_back(newComponent);
    }
}


\end{minted}

\subsection{bridges}
\begin{minted}{cpp}

// Bridges - pontes
// bridges: vetor de pontes
// Complexidade: O(V + E)
/*
    init(n);
    f(i,0,m){
        graph[a].push_back(b);
        graph[b].push_back(a);
    }
    f(i,0,n) if(!visited[i]) dfs(i,i);
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<bool> visited(MAXN);
vector<int> tin(MAXN);
vector<int> lowlink(MAXN);
vector<pair<int, int>> bridges;
int entryTime;

void init(int numV) {
    entryTime = 0;
    bridges.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        visited[i] = false;
    }
}

void dfs(int v, int parent) {
    visited[v] = true;
    lowlink[v] = tin[v] = entryTime++;

    for (int u : graph[v]) {
        if (!visited[u]) {
            dfs(u, v);
            lowlink[v] = min(lowlink[v], lowlink[u]);
        } else {
            if (u == parent) continue;

            lowlink[v] = min(lowlink[v], tin[u]);
        }
    }

    if (v != parent && lowlink[v] == tin[v]) {
        bridges.push_back({v, parent});
    }
}


\end{minted}

\subsection{centroid}
\begin{minted}{cpp}

// Centroid Decomposition e Centroid Tree

// c_tree contem a arvore de centroids
// c_par contem o pai de cada vertice na arvore de centroid
// dist[i] = distancia de i para os centroid

// O(n log(n)) (tempo e memoria)

vector<vector<int>> g(MAXN);

namespace centroid{
    vector<int> sz(MAXN);
    vector<bool> visit(MAXN,false);
    vector<vector<int>> c_tree(MAXN);
    vector<int> c_par(MAXN,-1);
    vector<vector<pair<int,int>>> dist(MAXN); // distancia, vertice

    void dfs_size(int v,int p=-1){
        sz[v] = 1;
        for(int u:g[v]) if(u!=p and !visit[u]){
            dfs_size(u,v);
            sz[v]+=sz[u];
        }
    }

    int find_centroid(int v, int size, int p=-1){
        for(int u:g[v])if(u!=p and !visit[u]){
            if(sz[u]>size/2) return find_centroid(u,size,v);
        }
        return v;
    }

    void dfs_dist(int v,int c,int p=-1,int d=0){
        dist[v].push_back({d,c});
        for(int u:g[v])if(u!=p and !visit[u]){
            dfs_dist(u,c,v,d+1);
        }
    }

    int build_centroid(int v=1){
        dfs_size(v);
        int c = find_centroid(v,sz[v]);

        visit[c] = true;
        dfs_dist(c,c);

        for(int u:g[c])if(!visit[u]){
            int neighbor = build_centroid(u);
            c_tree[c].push_back(neighbor);
            c_par[neighbor] = c;
        }

        return c;
    }

};

\end{minted}

\subsection{condensationGraph}
\begin{minted}{cpp}

// Condensation Graph
// Representa as componentes fortemente conexas de um grafo direcionado
// condensationGraph: grafo onde cada vértice é uma componente fortemente conexa
// Complexidade: O(V + E)
/*
    init(n);
    f(i,0,m) {
        graph[a].push_back(b);
        reverseGraph[b].push_back(a);
    }
    f(i,0,n) if(visited[i] == 0) dfs(i);

    int componentId = 0;
    for (int i = exitOrder.size()-1; i >= 0; i--) if(visited[exitOrder[i]] == 1) {
        components.push_back(vector<int>());
        dfs2(exitOrder[i], componentId++);
    }
    createCondensationGraph(n);

    cout << "Condensation graph num of vertices: " << components.size() << endl;
    for (int i = 0; i < components.size(); i++) {
        for (int j = 0; j < condensationGraph[i].size(); j++) {
            cout << "(" << i+1 << ", " << condensationGraph[i][j]+1 << ") ";
        }
    }
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> reverseGraph(MAXN);
vector<int> visited(MAXN);
vector<int> exitOrder;
vector<int> componentOfV(MAXN);
vector<unordered_set<int>> condensationGraphEdges(MAXN);
vector<vector<int>> condensationGraph(MAXN);
vector<vector<int>> components;

void init(int numV) {
    exitOrder.clear();
    components.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        reverseGraph[i].clear();
        condensationGraph[i].clear();
        condensationGraphEdges[i].clear();
        visited[i] = 0;
    }
}

void dfs(int v) {
    visited[v] = 1;

    for (int u : graph[v]) if (visited[u] == 0) dfs(u);

    exitOrder.push_back(v);
}

void dfs2(int v, int c) {
    visited[v] = 2;
    componentOfV[v] = c;
    components.back().push_back(v);

    for (int u : reverseGraph[v]) if (visited[u] == 1) dfs2(u, c);
}

void dfs3(int v, int parent) {
    if (componentOfV[v] != componentOfV[parent]) {
        condensationGraphEdges[componentOfV[parent]].insert(componentOfV[v]);
    }
    visited[v] = 3;

    for (int u : graph[v]) if (visited[u] == 2) dfs3(u, v);
}

void createCondensationGraph(int n) {
    for (int i = 0; i < n; i++) if(visited[i] == 2) dfs3(i,i);

    for (int i = 0; i < components.size(); i++) {
        condensationGraph[i].insert(condensationGraph[i].end(), condensationGraphEdges[i].begin(), condensationGraphEdges[i].end());
    }
}


\end{minted}

\subsection{dijkstra}
\begin{minted}{cpp}

// Dijkstra

// Calcula a menor distancia de x para todos o vertices
// d[i] = INF => nao existe caminho

//O(v log(e))

typedef pair<int,int> pii;
vector<vector<pii>> g; //vertice, peso

vector<int> dijkstra(int x){
    vector<int> d(g.size(), INF);
    priority_queue<pii, vector<pii>, greater<pii>> fila;
    d[x] = 0;
    fila.push({0, x});
    while(!fila.empty()){
        auto [vdist, v] = fila.top();
        fila.pop();
        if(vdist > d[v]) continue;
        for(auto[u, udist] : g[v]) if(d[u] > d[v] + udist){
            d[u] = d[v] + udist;
            fila.push({d[u], u});
        }
    }
    return d;
}


\end{minted}

\subsection{smallToLarge}
\begin{minted}{cpp}

// Small To Large
// 1. Faz queries sem update na subárvore
// 2. Resolve os filhos leves e depois os pesados. 
// 3. A resposta para os filhos leves é sempre adicionada e apagada. 
// 4. A resposta dos filhos pesados é mantida.
//
// O(N * log(N) * C(u))
// 
// C(u) é acomplexidade do update da
// informação de um vértice na resposta

void add(int u) {/* aqui adiciona a subarvore de u na resposta */}

void rem(int u) {/* aqui remove a subarvore de u da resposta */}
 
void solve(int u, int keep=1) {
    int mx = -1;
    for(int v : adj[u]) if(v != par[u]) {
        if(mx == -1 or subt[v] >= subt[mx]) {
            mx = v;
        }
    }
    for(int v : adj[u]) if(v != par[u] and v != mx) solve(v, 0);
    if(mx != -1) solve(mx, 1);
    /* aqui adiciona a informação de u na resposta */
    for(int v : adj[u]) if(v != par[u] and v != mx) add(v);
    /* aqui responde a query de u. ans[u] = ... */
    if(!keep) rem(u);
}

\end{minted}

\subsection{stronglyConnectedComponents}
\begin{minted}{cpp}

// Strongly Connected Components - Componentes fortemente conexas
// components: componentes fortemente conexas
// Complexidade: O(V + E)
/*
    init(n);
    f(i,0,m) {
        graph[a].push_back(b);
        reverseGraph[b].push_back(a);
    }
    f(i,0,n) if(visited[i] == 0) dfs(i);

    int componentId = 0;
    for (int i = exitOrder.size()-1; i >= 0; i--) if(visited[exitOrder[i]] == 1) {
        components.push_back(vector<int>());
        dfs2(exitOrder[i], componentId++);
    }
*/

const ll MAXN = 200010;
vector<vector<int>> graph(MAXN);
vector<vector<int>> reverseGraph(MAXN);
vector<int> visited(MAXN);
vector<int> exitOrder;
vector<int> componentOfV(MAXN);
vector<vector<int>> components;

void init(int numV) {
    exitOrder.clear();
    components.clear();
    for (int i = 0; i < numV; i++) {
        graph[i].clear();
        reverseGraph[i].clear();
        visited[i] = 0;
    }
}

void dfs(int v) {
    visited[v] = 1;

    for (int u : graph[v]) if (visited[u] == 0) dfs(u);

    exitOrder.push_back(v);
}

void dfs2(int v, int c) {
    visited[v] = 2;
    componentOfV[v] = c;
    components.back().push_back(v);

    for (int u : reverseGraph[v]) if (visited[u] == 1) dfs2(u, c);
}


\end{minted}

\subsection{tarjan}
\begin{minted}{cpp}

// Algoritmo de Tarjan para pontes
// O(n+m)

const int MAXN = 200010;

vector<bool> marc(MAXN,false);
vector<int> pre(MAXN),low(MAXN),comp(MAXN);
stack<int> pilha;

vector<int> grafo[MAXN];
vector<int> vertices_da_componente[MAXN];
vector<pair<int,int> > bridges;

vector<int> componente;

int t=0,c=0,p=0;

void dfs(int v,int pai){
    t++;
    pre[v] = t;
    low[v] = t;
    marc[v] = true;
    pilha.push(v);

    for(int viz:grafo[v]){
        if(!marc[viz]){
            dfs(viz,v);
            low[v] = min(low[v],low[viz]);
        }else{
            if(viz==pai) continue;
            low[v] = min(low[v],pre[viz]);
        }
    }

    if(low[v]==pre[v]){
        c++;
        int vertice;

        if(v!=0){
            bridges.push_back({v,pai});
        }

        do{
            vertice = pilha.top();
            pilha.pop();
            comp[vertice] = c;
            vertices_da_componente[c].push_back(vertice);
            componente[vertice] = c;
        }while(vertice != v);
    }
}


vector<vector<int> > bridgesTree(){
    vector<vector<int> > tree(c+1);
    for(int i=0;i<bridges.size();i++){
        auto [a,b] = bridges[i];
        tree[componente[a]].push_back(componente[b]);
        tree[componente[b]].push_back(componente[a]);
    }
    return tree;
}


\end{minted}

\section{Matematica}
\subsection{combinacao}
\begin{minted}{cpp}

// Combinacao
// comb(n,k) retorna a combinação de n elementos
// agrupados k a k 

ll fat[MAXN], invfat[MAXN];
 
ll inv(ll a, ll b) {
	return a > 1 ? b - inv(b%a, a)*b/a : 1;
}
 
ll comb(int n,int k){
    if(k>n) return 0;
    ll val = (fat[n] * invfat[n-k])%MOD;
    val = (val*invfat[k])%MOD;
    return val;
}

void init(){
    fat[0] = 1;
    invfat[0] = inv(fat[0],MOD);
    for(int i=1;i<MAXN;i++){
        fat[i] = (fat[i-1]*i)%MOD;
        invfat[i] = inv(fat[i],MOD);
    }
}

\end{minted}

\subsection{crivo}
\begin{minted}{cpp}

// Crivo de Eratosthenes

// crivo - O(n log(log(n)))
// fact - O(log(n))

ll _tam_crivo;
bitset<10000010> bs;
vector<int> primos;

void crivo(ll limite){
    _tam_crivo = limite +1;
    bs.reset();bs.flip();
    bs.set(0,false); bs.set(1,false);
    for(ll i=2;i<=_tam_crivo; i++){
        if(bs.test((size_t)i)){
            for(ll j = i*i; j<=_tam_crivo;j+=i){
                bs.set((size_t)j,false);
            }
            primos.push_back((int)i);
        }
    }
}

bool eh_primo(ll N){
    if(N<_tam_crivo) return bs.test(N);
    for(int i=0;i<primos.size();i++){
        if(N%primos[i]==0){
            return false;
        }
    }
    return true;
}

vector<int> primeFactors(int N){
    vector<int> factors;
    int PF_idx = 0, PF = primos[PF_idx];
    while(N!=1 && PF*PF <= N){
        while(N%PF == 0){
            N/=PF;
            factors.push_back(PF);
        }
        PF=primos[++PF_idx];
    }
    if(N!=1) factors.push_back(N);
    return factors;
}



\end{minted}

\section{Problemas}
\subsection{inversionCount}
\begin{minted}{cpp}

// Inversion Count com merge_sort
// Conta a quantidade de inversoes em um vetor
// O(n log(n))

template<typename T> ll merge_sort(vector<T> &v){
	if(v.size()==1) return 0;
	ll inv=0;

	vector<T> u1, u2;
	for(int i=0;i<v.size()/2;i++){
		u1.push_back(v[i]);
	}
	for(int i=v.size()/2;i<v.size();i++){
	 	u2.push_back(v[i]);
	}	

	inv+=merge_sort(u1);
	inv+=merge_sort(u2);
	
	u1.push_back(INF);
	u2.push_back(INF);
	
	int ini1=0, ini2=0;
	for(int i=0;i<v.size();i++){
		if(u1[ini1]<=u2[ini2]){
			v[i]=u1[ini1];
			ini1++;
		}else{
			v[i]=u2[ini2];
			ini2++;
			inv+=u1.size()-ini1-1;
		}
	}
	
	return inv;
}


\end{minted}

\section{Strings}
\subsection{Z}
\begin{minted}{cpp}

// Z function
//z[i] = maior prefixo comum com s a partir de da posição i
// Complexidade: O(|s|)

vector<int> Z(string s){
    int n = s.size();
    vector<int> z(n, 0);
    int l = 0, r = 0;
    for (int i = 1; i < n; i++){
        if (i <= r) z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < n and s[z[i]] == s[i + z[i]]) z[i]++;
        if (i + z[i] - 1 > r){
            l = i;
            r = i + z[i] - 1;
        }
    }
    return z;
}


\end{minted}

\section{UltimoRecurso}
\subsection{simulatedAnnealing}
\begin{minted}{cpp}

// Simulated Annealing
// Dado um vetor e uma função que o valor do vetor
// altera o vetor para conseguir o maior valor possível

// it = temperatura inicial (não alterar)
// cr = taxa de resfriamento
// ni = numero de iteracoes
// n = tamanho do vetor
// simulatedAnnealing = retorna o melhor valor encontrado

// Complexidade: O(ni*n)

#define ld long double

ld it = 100, cr = 0.999;
int ni = 100000;

int calculate(vector<int> &v) {
    // calcular um valor a partir de v
    // quanto mais perto v estiver da resposta
    // maior deve ser o valor retornado por essa função
}

int simulatedAnnealing(vector<int> &best) {
    ld t = it;
    vector<int> curr(best);
    int bestVal, currVal;
    bestVal = currVal = calculate(curr);

    for (int i = 0; i < ni; i++) {
        int r1 = rand()%curr.size();
        int r2 = rand()%curr.size();
        swap(curr[r1], curr[r2]);

        int newVal = calculate(curr);
        int d = currVal - newVal;

        if (d <= 0 || (rand() / static_cast<ld>(RAND_MAX)) < exp(-d / t)) {
            currVal = newVal;
            if (currVal > bestVal) {
                best = curr;
                bestVal = currVal;
            }
        } else swap(curr[r1], curr[r2]);
        
        t *= cr;
    }
    
    return bestVal;
}

int main() {
    srand(time(0));
    // main
    return 0;
}

\end{minted}

\section{Utils}
\subsection{IO}
\begin{minted}{py}

import sys
inputs = sys.stdin.read().splitlines() # make Python I/O faster

n = int(inputs[0])

ln = 1 # set current line = 0

for _ in range(n):
	a, b = map(int, inputs[ln].split())
	ln += 1
	print(a + b)

\end{minted}

\subsection{bitManipulation}
\begin{minted}{cpp}

#define isOn(S, j) (S & (1<<j))
#define setBit(S, j) (S |= (1<<j))
#define clearBit(S, j) (S &= ~(1<<j))
#define toggleBit(S, j) (S ^= (1<<j))
#define lowBit(S) (S & (-S))
#define setAll(S, n) (S = (1<<n)-1)

#define modulo(S, N) ((S) & (N-1))   // returns S % N, where N is a power of 2
#define isPowerOfTwo(S) (!(S & (S-1)))
#define nearestPowerOfTwo(S) (1<<lround(log2(S)))
#define turnOffLastBit(S) ((S) & (S-1))
#define turnOnLastZero(S) ((S) | (S+1))
#define turnOffLastConsecutiveBits(S) ((S) & (S+1))
#define turnOnLastConsecutiveZeroes(S) ((S) | (S-1))


\end{minted}

\subsection{pbds}
\begin{minted}{cpp}

#include <bits/stdc++.h>
using namespace std;

#include <bits/extc++.h>                         // pbds
using namespace __gnu_pbds;
typedef tree<int, null_type, less<int>, rb_tree_tag,
             tree_order_statistics_node_update> ost;

// To handle duplicates in the elements
// use less_equal<int> instead of less<int>

int main() {
  int n = 9;
  int A[] = { 2, 4, 7,10,15,23,50,65,71};
  ost tree;
  for (int i = 0; i < n; ++i)                    // O(n log n)
    tree.insert(A[i]);
  // O(log n) select
  cout << *tree.find_by_order(0) << "\n";        // 1-smallest = 2
  cout << *tree.find_by_order(n-1) << "\n";      // 9-smallest/largest = 71
  cout << *tree.find_by_order(4) << "\n";        // 5-smallest = 15
  // O(log n) rank
  cout << tree.order_of_key(2) << "\n";          // index 0 (rank 1)
  cout << tree.order_of_key(71) << "\n";         // index 8 (rank 9)
  cout << tree.order_of_key(15) << "\n";         // index 4 (rank 5)
  return 0;
}


\end{minted}

\subsection{shuffle}
\begin{minted}{cpp}

vector<int> v;

random_device rd;
mt19937 g(rd());
shuffle(v.begin(), v.end(), g);

\end{minted}

\section{Extra}
\subsection{debug}
\begin{minted}{cpp}

// Debug
// 1. Precisa compilar com -DDEBUG

// para pair
template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << "," << p.second << ')'; }

// para vector,set,...
template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = ","; return os << '}'; }

// debug
void debug_out(string s) { cerr << endl; }
template<typename H, typename... T>
void debug_out(string s, H h, T... t) {
    do { cerr << s[0]; s = s.substr(1);
    } while (s.size() and s[0] != ',');
    cerr << "=" << h;
    debug_out(s, t...);
}
#ifdef DEBUG
#define debug(...) cerr << "Line(" << __LINE__ << "): "; debug_out(#__VA_ARGS__, __VA_ARGS__)
#else
#define debug(...)
#endif

\end{minted}

\subsection{run}
\begin{minted}{sh}

#!/bin/bash
clear
g++ -std=c++17 -O2 -Wall $2 $1/$1.cpp
for file in $1/in*
do
    echo $file
    ./a.out <$file
    echo "-----------------------"
    echo
done

\end{minted}

\subsection{template}
\begin{minted}{cpp}

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

#define optimize ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
#define endl "\n"

#define all(x) (x).begin(),(x).end()

const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3fll;


int main(){
    optimize;


    return 0;
}

\end{minted}

\end{document}